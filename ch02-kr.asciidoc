[[ch02_bitcoin_overview]]
// == How Bitcoin Works
== 비트코인 작동원리
// === Transactions, Blocks, Mining, and the Blockchain
=== 거래, 블록, 채굴, 그리고 블록체인
// ((("bitcoin", "overview of", id="BCover02")))((("central trusted authority")))((("decentralized systems", "bitcoin overview", id="DCSover02")))The bitcoin system, unlike traditional banking and payment systems, is based on decentralized trust. Instead of a central trusted authority, in bitcoin, trust is achieved as an emergent property from the interactions of different participants in the bitcoin system. In this chapter, we will examine bitcoin from a high level by tracking a single transaction through the bitcoin system and watch as it becomes "trusted" and accepted by the bitcoin mechanism of distributed consensus and is finally recorded on the blockchain, the distributed ledger of all transactions. Subsequent chapters will delve into the technology behind transactions, the network, and mining.
((("bitcoin", "overview of", id="BCover02")))((("central trusted authority")))((("decentralized systems", "bitcoin overview", id="DCSover02")))기존 은행 및 결제 시스템과는 달리 비트코인 시스템은 분산된 신뢰를 기반으로 한다. 비트코인에서는 중앙 신뢰 기관 대신 비트코인 시스템 내의 서로 다른 여러 참여자들의 상호작용으로부터 발생하는 새로운 속성을 통해 신뢰를 형성한다. 2장에서는 비트코인 시스템을 통해 진행되는 거래 과정을 추적하여 상위 단계의 비트코인을 검토하고, 분산화된 합의 (distributed consensus)라는 비트코인 메커니즘에 의해 "신뢰 (trusted)"를 얻고 승인을 받은 후 모든 거래 내역의 분장인 블록체인에 기록되는 과정을 살펴볼 것이다. 이후 챕터에서는 거래, 네트워크 및 채굴에 대해 설명할 것이다.

// ==== Bitcoin Overview
==== 비트코인 개요

// In the overview diagram shown in <<bitcoin-overview>>, we see that the bitcoin system consists of users with wallets containing keys, transactions that are propagated across the network, and miners who produce (through competitive computation) the consensus blockchain, which is the authoritative ledger of all transactions.
<<bitcoin-overview>>에 제시된 개괄 도표에서는 키를 포함한 지갑을 소유한 사용자, 네트워크상으로 전파된 거래 및 거래내역 전부를 기록한 권위 있는 장부인 합의 블록체인을 (경쟁적 연산을 통해) 생산하는 채굴자들이 비트코인 시스템을 구성함을 알 수 있다.


// ((("blockchain explorer sites")))Each example in this chapter is based on an actual transaction made on the bitcoin network, simulating the interactions between the users (Joe, Alice, Bob, and Gopesh) by sending funds from one wallet to another. While tracking a transaction through the bitcoin network to the blockchain, we will use a _blockchain explorer_ site to visualize each step. A blockchain explorer is a web application that operates as a bitcoin search engine, in that it allows you to search for addresses, transactions, and blocks and see the relationships and flows between them.
((("blockchain explorer sites")))2장에서 제시될 각 사례는 비트코인 네트워크에서 이루어진 실제 거래를 기반으로 하며, 지갑간 자금 이동을 통해 사용자 (조, 앨리스, 밥, 그리고 고페시) 사이의 상호작용을 시뮬레이션한다. 비트코인 네트워크를 통해 블록체인으로의 거래를 추적하면서, _블록체인 익스플로러_ 를 사용하여 각 단계를 시각화 할 것이다. 블록체인 익스플로러는 주소, 거래 및 블록을 검색할 수 있고 그들 사이의 관계와 흐름을 파악할 수 있는 비트코인 검색 엔진으로써 작동하는 웹 어플리케이션이다.

[[bitcoin-overview]]
// .Bitcoin overview
.비트코인 개요
image::images/mbc2_0201.png["Bitcoin Overview"]

// ((("Bitcoin Block Explorer")))((("BlockCypher Explorer")))((("blockchain.info")))((("BitPay Insight")))Popular blockchain explorers include:
((("Bitcoin Block Explorer")))((("BlockCypher Explorer")))((("blockchain.info")))((("BitPay Insight")))인기 있는 블록체인 익스플로러는 다음과 같다:

* https://live.blockcypher.com[BlockCypher Explorer]
* https://blockchain.info[blockchain.info]
* https://insight.bitpay.com[BitPay Insight]

// Each of these has a search function that can take a bitcoin address, transaction hash, block number, or block hash and retrieve corresponding information from the bitcoin network. With each transaction or block example, we will provide a URL so you can look it up yourself and study it in detail.
각 서비스는 비트코인 주소, 거래 해시, 블록 번호 또는 블록 해시를 검색하여 비트코인 네트워크에서 관련 정보를 찾아낼 수 있다. 각 거래 또는 블록 예시를 통해 바로 접속할 수 있는 URL을 제공하므로 이를 통해 상세하게 학습하길 바란다.


[[cup_of_coffee]]
// ==== Buying a Cup of Coffee
==== 커피 구매하기

// ((("use cases", "buying coffee", id="UCcoffee02")))Alice, introduced in the previous chapter, is a new user who has just acquired her first bitcoin. In <<getting_first_bitcoin>>, Alice met with her friend Joe to exchange some cash for bitcoin. The transaction created by Joe funded Alice's wallet with 0.10 BTC. Now Alice will make her first retail transaction, buying a cup of coffee at Bob's coffee shop in Palo Alto, California.
((("use cases", "buying coffee", id="UCcoffee02")))1장에서 등장했던 앨리스는 이제 막 비트코인을 구매하여 새로운 사용자가 되었다. <<getting_first_bitcoin>>에서 앨리스는 친구인 조를 만나 현금을 비트코인으로 교환했다. 조가 생성한 거래를 통해 앨리스의 지갑에는 0.10 BTC가 전송되었다. 이제 앨리스는 캘리포니아 팔로알토에 있는 밥의 까페에서 커피를 구매하는 첫 소매 거래를 할 것이다.

// ((("exchange rates", "determining")))Bob's Cafe recently started accepting bitcoin payments by adding a bitcoin option to its point-of-sale system. The prices at Bob's Cafe are listed in the local currency (US dollars), but at the register, customers have the option of paying in either dollars or bitcoin. Alice places her order for a cup of coffee and Bob enters it into the register, as he does for all transactions.  The point-of-sale system automatically converts the total price from US dollars to bitcoin at the prevailing market rate and displays the price in both currencies:
((("exchange rates", "determining")))밥의 까페는 최근 POS 시스템 (point-of sale system)에 비트코인 옵션을 추가하여 비트코인을 결제 수단으로 받기 시작했다. 밥의 까페의 가격은 국내 통화 (US 달러) 단위로 표시되어 있지만 계산대에서는 고객이 달러와 비트코인 중에서 지불 수단을 선택할 수 있다. 앨리스는 커피 한 잔을 주문했고 밥은 계산대에 거래 내역을 입력한다. POS 시스템은 자동적으로 달러로 표기된 총 가격을 일반적인 시세에 따라 비트코인으로 전환한 후 두 가지 통화 단위에 대한 가격을 모두 보여준다.

// ----
// Total:
// $1.50 USD
// 0.015 BTC
// ----
----
총 가격:
$1.50 USD
0.015 BTC
----

// ((("millibits")))Bob says, "That's one-dollar-fifty, or fifteen millibits."
((("millibits")))밥은 "1.5달러나 0.015 BTC를 지불하시면 됩니다" 라고 말한다.

// ((("payment requests")))((("QR codes", "payment requests")))Bob's point-of-sale system will also automatically create a special QR code containing a _payment request_ (see <<payment-request-QR>>).
((("payment requests")))((("QR codes", "payment requests")))또한 밥의 POS 시스템은 자동적으로 _지불 요청 (payment request)_ 을 포함한 QR코드를 생성할 것이다 (<<payment-request-QR>>을 참조하라).

// Unlike a QR code that simply contains a destination bitcoin address, a payment request is a QR-encoded URL that contains a destination address, a payment amount, and a generic description such as "Bob's Cafe." This allows a bitcoin wallet application to prefill the information used to send the payment while showing a human-readable description to the user. You can scan the QR code with a bitcoin wallet application to see what Alice would see.
단순히 송금할 비트코인 주소만 포함한 QR코드와는 달리 지불 요청은 QR코드로 인코딩된 URL로서 송금 주소, 지불 금액 및 밥의 까페와 같은 지불과 관련된 일반적인 설명도 포함한다. 이를 통해 비트코인 지갑 어플리케이션에 지불하는 데 사용되는 정보를 미리 넣어 둘 수 있고, 동시에 사용자가 읽을 수 있는 정보도 제공한다. 당신은 비트코인 지갑 어플리케이션을 사용하여 QR코드를 스캔할 수 있고 이를 통해 앨리스가 어떤 화면을 보는 지 알 수 있다.


[[payment-request-QR]]
// .Payment request QR code
.지불 요청 QR코드
image::images/mbc2_0202.png["payment-request"]

[TIP]
====
// ((("QR codes", "warnings and cautions")))((("transactions", "warnings and cautions")))((("warnings and cautions", "avoid sending money to addresses appearing in book")))Try to scan this with your wallet to see the address and amount but DO NOT SEND MONEY.
((("QR codes", "warnings and cautions")))((("transactions", "warnings and cautions")))((("warnings and cautions", "avoid sending money to addresses appearing in book")))당신의 지갑으로 이것을 스캔해 보면 주소와 금액을 확인할 수 있다. 이 주소로 돈을 전송하지 마시오!
====

[[payment-request-URL]]
// .The payment request QR code encodes the following URL, defined in BIP-21:
.지불 요청 QR코드는 BIP-21에서 규정된 다음의 URL을 인코딩한다.
----
bitcoin:1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA?
amount=0.015&
label=Bob%27s%20Cafe&
message=Purchase%20at%20Bob%27s%20Cafe

Components of the URL

A bitcoin address: "1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA"
The payment amount: "0.015"
A label for the recipient address: "Bob's Cafe"
A description for the payment: "Purchase at Bob's Cafe"
----

// Alice uses her smartphone to scan the barcode on display. Her smartphone shows a payment of +0.0150 BTC+ to +Bob's Cafe+ and she selects Send to authorize the payment. Within a few seconds (about the same amount of time as a credit card authorization), Bob sees the transaction on the register, completing the transaction.
앨리스는 스마트폰을 사용해 표시된 바코드를 스캔한다. 앨리스는 스마트폰을 통해 0.0150 BTC를 밥의 까페에 지불한다는 내용을 확인하고 전송 버튼을 눌러 지불을 승인한다. 몇 초 후에 (신용카드 승인 시간과 거의 유사) 밥은 계산대에서 거래가 완료되는 화면을 볼 수 있다.

// In the following sections, we will examine this transaction in more detail. We'll see how Alice's wallet constructed it, how it was propagated across the network, how it was verified, and finally, how Bob can spend that amount in subsequent transactions.
다음 섹션에서는 이 거래에 대해 더 자세하게 살펴볼 것이다. 앨리스의 지갑이 어떻게 거래를 성사시키는지, 거래가 네트워크를 통해 어떻게 전파되는지, 해당 거래가 어떻게 검증되는지, 그리고 마지막으로 밥이 전송받은 금액을 차후 거래에 어떻게 사용할 수 있는지에 대해 알아 볼 것이다.

[NOTE]
====
// ((("fractional values")))((("milli-bitcoin")))((("satoshis")))The bitcoin network can transact in fractional values, e.g., from millibitcoin (1/1000th of a bitcoin) down to 1/100,000,000th of a bitcoin, which is known as a satoshi.  Throughout this book, we’ll use the term “bitcoin” to refer to any quantity of bitcoin currency, from the smallest unit (1 satoshi) to the total number (21,000,000) of all bitcoin that will ever be mined.
((("fractional values")))((("milli-bitcoin")))((("satoshis")))비트코인 네트워크에서는 소수로 거래할 수 있다. 예를 들어, 1 밀리비트코인 (0.001 비트코인)에서부터 사토시라고 알려진 0.00000001 비트코인까지 거래가 가능하다. 이 책에서는 가장 작은 단위 (1 사토시)에서부터 앞으로 채굴될 모든 비트코인의 총 합 (21,000,000)까지를 아우르는 비트코인 통화의 어떤 수를 지칭할 때 "비트코인"이라는 용어를 사용할 것이다.
====

// You can examine Alice's transaction to Bob's Cafe on the blockchain using a block explorer site (<<view_alice_transaction>>):
당신은 앨리스가 밥의 까페에 전송한 거래 내역을 블록 익스플로러 사이트를 사용하여 블록체인에서 확인할 수 있다 (<<view_alice_transaction>>):

[[view_alice_transaction]]
// .View Alice's transaction on
.앨리스의 거래를 여기에서 확인하라 https://blockchain.info/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2[blockchain.info]
====
----
https://blockchain.info/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2
----
====

// === Bitcoin Transactions
=== 비트코인 거래

// ((("transactions", "defined")))In simple terms, a transaction tells the network that the owner of some bitcoin value has authorized the transfer of that value to another owner. The new owner can now spend the bitcoin by creating another transaction that authorizes the transfer to another owner, and so on, in a chain of ownership.
((("transactions", "defined")))간단히 설명하자면, 거래는 비트코인 소유자가 해당 비트코인을 다른 사람에게 전송하는 것을 승인했음을 네트워크에 알려주는 것이다. 새로운 소유자는 이제 소유권의 체인에서 계속해서 또 다른 소유자에게로 비트코인 전송을 승인하는 거래를 생성함으로써 비트코인을 소비할 수 있다.

// ==== Transaction Inputs and Outputs
==== 거래 입력값 (inputs)과 출력값 (outputs)

// ((("transactions", "overview of", id="Tover02")))((("outputs and inputs", "basics of")))Transactions are like lines in a double-entry bookkeeping ledger.  Each transaction contains one or more "inputs," which are like debits against a bitcoin account. On the other side of the transaction, there are one or more "outputs," which are like credits added to a bitcoin account. ((("fees", "transaction fees")))The inputs and outputs (debits and credits) do not necessarily add up to the same amount. Instead, outputs add up to slightly less than inputs and the difference represents an implied _transaction fee_, which is a small payment collected by the miner who includes the transaction in the ledger. A bitcoin transaction is shown as a bookkeeping ledger entry in <<transaction-double-entry>>.
((("transactions", "overview of", id="Tover02")))((("outputs and inputs", "basics of")))거래는 복식부기 장부와 유사하다. 각 거래는 비트코인 계좌에서 빠져나가는 차변 (debit)인 하나 이상의 "입력값"을 포함한다. 거래의 또 다른 구성요소로서 비트코인 계좌로 들어오는 대변 (credit)인 하나 이상의 "출력값"을 포함한다. ((("fees", "transaction fees")))입력값과 출력값 (차변과 대변)의 합계가 반드시 동일할 필요는 없다. 대신 출력값의 총합은 입력값의 총합보다 약간 작아야 하며, 이 차이는 거래 속에 포함된 _거래 수수료 (transaction fee)_ 이다. 거래 수수료는 거래를 장부에 포함시킨 채굴자가 수거하는 소액의 지불금이다. 비트코인 거래는 그림 <<transaction-double-entry>>에 잘 나타나 있으며 복식부기 장부와 유사하다.

// The transaction also contains proof of ownership for each amount of bitcoin (inputs) whose value is being spent, in the form of a digital signature from the owner, which can be independently validated by anyone. ((("spending bitcoin", "defined")))In bitcoin terms, "spending" is signing a transaction that transfers value from a previous transaction over to a new owner identified by a bitcoin address.
또한 각 소비되는 비트코인의 금액 (입력값)에 대한 소유권을 소유자의 디지털 서명의 형태로 증명하는 과정이 거래에 포함되며, 누구든지 독립적으로 거래를 검증할 수 있다. ((("spending bitcoin", "defined")))비트코인 용어에서, "소비 (spending)"는 이전 거래에서 송금되었던 금액이 비트코인 주소에 의해 확인된 새로운 소유자에게로 전송되는 거래에 서명함을 뜻한다.

[[transaction-double-entry]]
// .Transaction as double-entry bookkeeping
.복식부기 장부 형태의 거래
image::images/mbc2_0203.png["Transaction Double-Entry"]

// ==== Transaction Chains
==== 거래 체인 (chain)

// ((("chain of transactions")))Alice's payment to Bob's Cafe uses a previous transaction's output as its input. In the previous chapter, Alice received bitcoin from her friend Joe in return for cash. That transaction created a bitcoin value locked by Alice's key. Her new transaction to Bob's Cafe references the previous transaction as an input and creates new outputs to pay for the cup of coffee and receive change. The transactions form a chain, where the inputs from the latest transaction correspond to outputs from previous transactions. Alice's key provides the signature that unlocks those previous transaction outputs, thereby proving to the bitcoin network that she owns the funds. She attaches the payment for coffee to Bob's address, thereby "encumbering" that output with the requirement that Bob produces a signature in order to spend that amount. This represents a transfer of value between Alice and Bob. This chain of transactions, from Joe to Alice to Bob, is illustrated in <<blockchain-mnemonic>>.
((("chain of transactions")))앨리스가 밥의 까페에 지불을 할 때 이전 거래의 출력값을 입력값으로 사용했다. 1 장에서는, 앨리스는 현금을 주고 친구인 조에게서 비트코인을 구매했다. 이 거래에서 앨리스가 보유한 키에 의해 잠겨있는 비트코인 금액이 생성되었다. 앨리스가 밥의 까페에서 새로운 거래를 하게 되면 이전 거래를 입력값으로 참조하고 커피값 지불을 위해 새로운 출력값을 생성하고 나머지 잔액을 돌려받는다. 거래는 체인을 생성하며, 가장 최근 거래에서 생성된 입력값이 그 이전 거래에서 발생한 출력값에 대응한다. 앨리스의 키는 이전 거래 출력값의 암호를 풀 수 있는 서명을 제공하며, 이를 통해 비트코인 네트워크에 앨리스의 소유권을 증명한다. 앨리스가 밥의 비트코인 주소로 커피값을 지불함으로써, 밥이 이 금액을 소비하기 위해서는 서명을 해야한다는 요구사항을 포함한 출력값이 "예상지출 상태가 된다 (encumbering)". 이것이 바로 앨리스와 밥 사이에서 가치가 전송되는 과정이다. 친구 조에서 앨리스, 밥까지 이어지는 거래 체인이 <<blockchain-mnemonic>>에 표시되어 있다.

[[blockchain-mnemonic]]
// .A chain of transactions, where the output of one transaction is the input of the next transaction
.한 거래의 출력값이 다음 거래의 입력값이 되는 거래 체인
image::images/mbc2_0204.png["Transaction chain"]

// ==== Making Change
==== 잔액 생성

// ((("change, making")))((("change addresses")))((("addresses", "change addresses")))Many bitcoin transactions will include outputs that reference both an address of the new owner and an address of the current owner, called the _change_ address. This is because transaction inputs, like currency notes, cannot be divided. If you purchase a $5 US dollar item in a store but use a $20 US dollar bill to pay for the item, you expect to receive $15 US dollars in change. The same concept applies to bitcoin transaction inputs. If you purchased an item that costs 5 bitcoin but only had a 20 bitcoin input to use, you would send one output of 5 bitcoin to the store owner and one output of 15 bitcoin back to yourself as change (less any applicable transaction fee). Importantly, the change address does not have to be the same address as that of the input and for privacy reasons is often a new address from the owner's wallet.
((("change, making")))((("change addresses")))((("addresses", "change addresses"))) 많은 비트코인 거래는 새로운 소유주 주소와 현재 소유주 주소를 모두 참조하는 출력값을 포함하며 이를 _잔액 (change)_ 주소라고 한다. 이는 실생활에 쓰이는 화폐처럼 거래 입력값을 나눌 수 없기 때문이다. 만약 당신이 가게에서 5 달러치 물품을 구입하고 결제 시 20 달러를 지불했다면, 당신은 잔액으로 15 달러를 받을 것이다. 동일한 컨셉이 비트코인 거래 입력값에도 적용된다. 만약 당신이 5 비트코인치 물품을 구입했지만 20 비트코인 입력값만 가지고 있다면, 당신은 가게 주인에게 5 비트코인 출력값을 보내고 잔액으로 15 비트코인을 당신 주소로 되돌려 보낸다 (전송 수수료로 인해 더 적을 수 있음). 중요한 것은 잔액 주소는 입력값 주소와 동일하지 않아도 되고 사생활 보호를 위해 주로 새로운 주소로 사용된다.

// Different wallets may use different strategies when aggregating inputs to make a payment requested by the user. They might aggregate many small inputs, or use one that is equal to or larger than the desired payment. Unless the wallet can aggregate inputs in such a way to exactly match the desired payment plus transaction fees, the wallet will need to generate some change. This is very similar to how people handle cash. If you always use the largest bill in your pocket, you will end up with a pocket full of loose change. If you only use the loose change, you'll always have only big bills. People subconsciously find a balance between these two extremes, and bitcoin wallet developers strive to program this balance.
서로 다른 지갑들은 사용자가 요청한 지불을 수행하기 위해 입력값을 합할 때 각각 다른 전략을 사용할 수 있다. 많은 작은 입력값을 합하거나 원하는 지불 금액과 동일하거나 더 큰 입력값을 사용할 수도 있다. 지갑이 원하는 지불 금액과 거래 수수료를 합한 금액을 정확하게 일치시키는 방식으로 입력값을 합할 수 없다면, 지갑은 잔액을 생성해야 한다. 이는 사람들이 현금을 취급하는 방식과 매우 유사하다. 당신이 항상 단위가 큰 지폐만 사용한다면, 당신의 주머니는 잔돈으로 가득 찰 것이다. 만약 당신이 잔액만 사용하는 경우, 항상 큰 단위의 지폐만 남게 될 것이다. 사람들은 무의식적으로 이 두 극단적인 상황의 균형을 맞출려고 하고 비트코인 지갑 개발자는 이러한 균형을 프로그래밍하기 위해 노력한다.

// ((("transactions", "defined")))((("outputs and inputs", "defined")))((("inputs", see="outputs and inputs")))In summary, _transactions_ move value from _transaction inputs_ to _transaction outputs_. An input is a reference to a previous transaction's output, showing where the value is coming from. A transaction output directs a specific value to a new owner's bitcoin address and can include a change output back to the original owner. Outputs from one transaction can be used as inputs in a new transaction, thus creating a chain of ownership as the value is moved from owner to owner (see <<blockchain-mnemonic>>).
((("transactions", "defined")))((("outputs and inputs", "defined")))((("inputs", see="outputs and inputs")))요약하자면, _거래_ 는 _거래 입력값_ 에서 _거래 출력값_ 으로 가치가 이동하는 것이다. 입력값은 이전 거래 출력값의 참조이며 그 가치가 어디에서 왔는지 보여준다. 거래 출력값은 새로운 소유주 주소로 특정 가치가 이동하는 것이며 기존 소유주에게 돌아가는 잔액 출력값을 포함할 수 있다. 한 거래로부터의 출력값은 새로운 거래에서 입력값으로 사용될 수 있으므로, 가치가 기존 소유자에서 다른 소유자로 이동함에 따라 소유권 체인이 생성된다. ( <<blockchain-mnemonic>>를 참고하라).


// ==== Common Transaction Forms
==== 일반적인 거래 유형

// The most common form of transaction is a simple payment from one address to another, which often includes some "change" returned to the original owner. This type of transaction has one input and two outputs and is shown in <<transaction-common>>.
가장 일반적인 거래 유형은 하나의 주소에서 다른 주소로 단일 거래가 이루어 지는 형태이며 주로 원 소유주에게 돌려줘여 하는 "잔액"이 존재한다. 이러한 거래는 하나의 입력값과 두 개의 출력값이 발생하게 되며 <<transaction-common>>를 참조하길 바란다.

[[transaction-common]]
// .Most common transaction
.가장 일반적인 거래
image::images/mbc2_0205.png["Common Transaction"]

// Another common form of transaction is one that aggregates several inputs into a single output (see <<transaction-aggregating>>). This represents the real-world equivalent of exchanging a pile of coins and currency notes for a single larger note. Transactions like these are sometimes generated by wallet applications to clean up lots of smaller amounts that were received as change for payments.
또 다른 일반적인 거래 유형은 여러 개의 입력값을 하나의 출력값으로 합하는 거래이다 (<<transaction-aggregating>>을 참고하라). 이 유형은 실생활에서 동전과 단위가 작은 지폐를 큰 단위의 지폐 한 장으로 교환하는 행위와 동일하다. 이러한 거래는 지불 과정의 잔액으로 받은 작은 단위의 금액을 정리하기 위해 지갑 어플리케이션에서 때때로 실행되기도 한다.

[[transaction-aggregating]]
// .Transaction aggregating funds
.자금을 합산하는 거래
image::images/mbc2_0206.png["Aggregating Transaction"]

// Finally, another transaction form that is seen often on the bitcoin ledger is a transaction that distributes one input to multiple outputs representing multiple recipients (see <<transaction-distributing>>). This type of transaction is sometimes used by commercial entities to distribute funds, such as when processing payroll payments to multiple employees.((("", startref="Tover02")))
마지막으로 비트코인 장부에서 주로 나타나는 다른 유형의 거래는 하나의 입력값을 여러 명의 수신인을 나타내는 여러 개의 출력값으로 분배하는 형태이다 (<<transaction-distributing>>을 참고하라). 이러한 거래 유형은 때때로 기업체에서 다수의 직원에게 급여를 지불하는 등 자금을 분배하는 경우에 사용된다.((("", startref="Tover02")))

[[transaction-distributing]]
// .Transaction distributing funds
.자금을 분배하는 거래
image::images/mbc2_0207.png["Distributing Transaction"]

// === Constructing a Transaction
=== 거래의 구성

// ((("transactions", "constructing", id="Tconstruct02")))((("wallets", "constructing transactions")))Alice's wallet application contains all the logic for selecting appropriate inputs and outputs to build a transaction to Alice's specification. Alice only needs to specify a destination and an amount, and the rest happens in the wallet application without her seeing the details. Importantly, a wallet application can construct transactions even if it is completely offline. Like writing a check at home and later sending it to the bank in an envelope, the transaction does not need to be constructed and signed while connected to the bitcoin network.
((("transactions", "constructing", id="Tconstruct02")))((("wallets", "constructing transactions")))앨리스의 지갑 어플리케이션에는 앨리스의 명세서대로 거래를 진행하기 위해 적절한 입력값과 출력값을 선택하는데 필요한 모든 논리가 포함되어 있다. 앨리스는 단지 송금 목적지와 금액만 기입하면 나머지는 앨리스가 자세한 사항을 몰라도 지갑 어플리케이션 내에서 진행된다. 중요한 것은 지갑 어플리케이션은 완전히 오프라인 상태일 때에도 지갑 어플리케이션을 통해 거래가 진행될 수 있다는 점이다. 집에서 수표를 작성하고 나중에 우편으로 은행으로 전달하는 것과 마찬가지로, 비트코인 거래도 굳이 비트코인 네트워크가 온라인일 때에만 진행되고 서명될 필요는 없다.

// ==== Getting the Right Inputs
==== 올바른 입력값 얻기

// ((("outputs and inputs", "locating and tracking inputs")))Alice's wallet application will first have to find inputs that can pay the amount she wants to send to Bob. Most wallets keep track of all the available outputs belonging to addresses in the wallet. Therefore, Alice's wallet would contain a copy of the transaction output from Joe's transaction, which was created in exchange for cash (see <<getting_first_bitcoin>>). A bitcoin wallet application that runs as a full-node client actually contains a copy of every unspent output from every transaction in the blockchain. This allows a wallet to construct transaction inputs as well as quickly verify incoming transactions as having correct inputs. However, because a full-node client takes up a lot of disk space, most user wallets run "lightweight" clients that track only the user's own unspent outputs.
((("outputs and inputs", "locating and tracking inputs")))우선 앨리스의 지갑 어플리케이션은 밥에게 전송하기를 원하는 금액을 지불할 수 있도록 알맞은 입력값을 찾아야 한다. 대부분 지갑은 지갑 내 주소에 속한 모든 가능한 출력값을 파악하고 있다. 그러므로 앨리스의 지갑은 현금과 비트코인을 교환했던 조와의 거래에서 생성된 거래 출력값 복사본이 포함되어 있을 것이다 (<<getting_first_bitcoin>>을 참고하라). 풀 노드 클라이언트 (full-node client)를 사용하는 비트코인 지갑 어플리케이션은 실제로 블록체인상에 있는 모든 거래에서 발생한 소비되지 않은 출력값의 모든 복사본을 보유하고 있다. 이는 지갑에서 거래 입력값을 생성할 수 있을 뿐만 아니라 정확한 입력값을 가지고 향후 거래를 신속하게 검증할 수 있도록 해 준다. 그러나 풀 노드 클라이언트의 경우 디스크 공간을 많이 차지하기 때문에 대부분의 사용자 지갑은 단지 사용자 본인의 소비되지 않은 출력값만 추적하는 "라이트웨이트 (lightweight)" 클라이언트를 실행한다.

// If the wallet application does not maintain a copy of unspent transaction outputs, it can query the bitcoin network to retrieve this information using a variety of APIs available by different providers or by asking a full-node using an application programming interface (API) call. <<example_2-2>> shows an API request, constructed as an HTTP GET command to a specific URL. This URL will return all the unspent transaction outputs for an address, giving any application the information it needs to construct transaction inputs for spending. We use the simple command-line HTTP client _cURL_ to retrieve the response.
지갑 어플리케이션에 소비되지 않은 출력값 복사본이 보관되어 있지 않은 경우, 다른 제공자들에 의해 사용 가능한 다양한 API를 이용하거나 API를 이용하고 있는 풀 노드에 요청해서 해당 정보를 검색해 달라고 비트코인 네트워크에 요청할 수 있다. <<example_2-2>>는 특정 URL에 대한 HTTP GET 명령으로 생성된 API 요청을 나타낸다. 이 URL은 비트코인 주소에서 모든 소비되지 않은 거래 출력값을 전부 반환하여 어플리케이션에서 소비를 위해 필요한 거래 입력값을 생성하도록 필요한 정보를 제공한다. 단순한 명령행인 HTTP 클라이언트 _cURL_ 을 사용하여 결과를 검색한다.

[[example_2-2]]
// .Look up all the unspent outputs for Alice's bitcoin address
.앨리스 비트코인 주소의 소비되지 않은 출력값 전수 조사
====
[source,bash]
----
$ curl https://blockchain.info/unspent?active=1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK
----
====

[source,json]
----
{

	"unspent_outputs":[

		{
			"tx_hash":"186f9f998a5...2836dd734d2804fe65fa35779",
			"tx_index":104810202,
			"tx_output_n": 0,
			"script":"76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac",
			"value": 10000000,
			"value_hex": "00989680",
			"confirmations":0
		}

	]
}
----


// The response in <<example_2-2>> shows one unspent output (one that has not been redeemed yet) under the ownership of Alice's address +1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK+. The response includes the reference to the transaction in which this unspent output is contained (the payment from Joe) and its value in satoshis, at 10 million, equivalent to 0.10 bitcoin. With this information, Alice's wallet application can construct a transaction to transfer that value to new owner addresses.
<<example_2-2>>에 나와 있는 결과는 앨리스의 비트코인 주소인 +1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK+ 가 소유권을 가진 출력값 중에 소비되지 않은 출력값이 하나 있다는 것을 보여준다 (아직 사용되지 않은 하나는 교환되지 않았음). 이 검색 결과는 소비되지 않은 출력값 (조가 지불한 금액)이 들어있는 거래에 대한 참조를 포함하며, 이 금액은 1000만 사토시, 즉 0.10 비트코인이다. 이 정보를 통해 앨리스의 지갑 어플리케이션은 해당 가치를 새로운 소유주 주소로 전송하기 위한 거래를 구성할 수 있다.

[TIP]
====
// View the http://bit.ly/1tAeeGr[transaction from Joe to Alice].
http://bit.ly/1tAeeGr[조가 앨리스로에게 전송한 거래]를 참조하라.
====

// As you can see, Alice's wallet contains enough bitcoin in a single unspent output to pay for the cup of coffee. Had this not been the case, Alice's wallet application might have to "rummage" through a pile of smaller unspent outputs, like picking coins from a purse until it could find enough to pay for the coffee. In both cases, there might be a need to get some change back, which we will see in the next section, as the wallet application creates the transaction outputs (payments).
보다시피 앨리스의 지갑은 커피값을 지불하기에 충분한 비트코인을 소비되지 않은 출력값 하나에 보유하고 있다. 그렇지 못한 경우라면, 앨리스의 지갑 어플리케이션은 마치 커피 한 잔을 사기 위해 충분한 금액이 될 때까지 지갑에서 동전을 꺼내는 것처럼, 소액의 소비되지 않은 출력값 더미를 "샅샅이 검색해야 (rummage)"할 수도 있다. 이 두 경우 모두 잔액을 돌려 받아야 할 수 있다. 이 내용은 다음 섹션의 지갑 어플리케이션이 거래 출력값 (지불)을 생성하는 과정에서 살펴볼 것이다.


// ==== Creating the Outputs
==== 출력값 생성하기

// ((("outputs and inputs", "creating outputs")))A transaction output is created in the form of a script that creates an encumbrance on the value and can only be redeemed by the introduction of a solution to the script. In simpler terms, Alice's transaction output will contain a script that says something like, "This output is payable to whoever can present a signature from the key corresponding to Bob's public address." Because only Bob has the wallet with the keys corresponding to that address, only Bob's wallet can present such a signature to redeem this output. Alice will therefore "encumber" the output value with a demand for a signature from Bob.
((("outputs and inputs", "creating outputs"))) 거래 출력값은 해당 가치에 대한 예상지출을 생성하는 스크립트의 형태로 생성되며, 스크립트에 대한 솔루션이 제공되는 경우에만 사용할 수 있다. 간단히 말하자면, 앨리스의 거래 출력값은 "이 출력값은 밥의 공개키에 대응하는 키를 이용해 서명을 하는 누구에게나 지불 가능하다"라는 의미가 담겨있는 스크립트를 포함할 것이다. 해당 비트코인 주소에 대응하는 키를 가진 지갑을 소유한 사람은 밥 뿐이기 때문에 밥의 지갑에서만 이 출력값을 사용할 수 있는 서명을 제공할 수 있다. 따라서 앨리스는 밥의 서명을 요구하는 출력값에 대한 "지출을 예상할" 수 있다.


// This transaction will also include a second output, because Alice's funds are in the form of a 0.10 BTC output, too much money for the 0.015 BTC cup of coffee. Alice will need 0.085 BTC in change. Alice's change payment is created by Alice's wallet as an output in the very same transaction as the payment to Bob. Essentially, Alice's wallet breaks her funds into two payments: one to Bob and one back to herself. She can then use (spend) the change output in a subsequent transaction.
또한 이 거래는 출력값이 하나 더 존재 할 것이며, 이것은 앨리스의 돈이 0.10 BTC 출력값의 형태이지만 이 금액은 커피 한 잔 가격인 0.015 BTC에 비하면 너무 큰 금액이기 때문이다. 앨리스는 0.085 BTC를 돌려받아야 한다. 앨리스의 잔액에 대한 지불은 밥에 대한 지불과 동일한 거래 내에서 이루어지며 앨리스의 지갑에 출력값으로 생성된다. 기본적으로 앨리스의 지갑에서는 그녀가 보유한 자금을 두 가지 거래로 나눈다: 하나는 밥에게로, 나머지 하나는 그녀 자신에게 돌아가는 거래이다. 그 후 앨리스는 다음 거래에서 잔액 출력값을 사용 (지불)할 수 있다.

// Finally, for the transaction to be processed by the network in a timely fashion, Alice's wallet application will add a small fee. This is not explicit in the transaction; it is implied by the difference between inputs and outputs. If instead of taking 0.085 in change, Alice creates only 0.0845 as the second output, there will be 0.0005 BTC (half a millibitcoin) left over. The input's 0.10 BTC is not fully spent with the two outputs, because they will add up to less than 0.10. The resulting difference is the _transaction fee_ that is collected by the miner as a fee for validating and including the transaction in a block to be recorded on the blockchain.
마지막으로 거래가 네트워크에서 적시에 처리되기 위해서 앨리스의 지갑 어플리케이션은 소액의 수수료를 추가할 것이다. 이 금액은 거래 내에 명시되어 있지 않으며 입력값과 출력값의 차이로 알 수 있다. 만약 잔액으로 0.085를 돌려 받는 대신 앨리스가 두 번째 출력값으로 0.0845를 생성했다면, 0.0005 BTC (0.5 밀리비트코인)가 남게 된다. 0.10 BTC 입력값이 두 가지 출력값에 모두 사용되는 것은 아니며, 이는 두 출력값의 총합이 0.10 미만이 되어야 하기 때문이다. 산출되는 입력값과 출력값의 차이를 _거래 수수료 (transaction fee)_ 라고 하며, 블록체인에 기록되는 블록에 거래를 포함시키고 검증하는 명목으로 채굴자들에게 지불되는 수수료이다.

// The resulting transaction can be seen using a blockchain explorer web application, as shown in <<transaction-alice>>.
거래 결과는 <<transaction-alice>>에 표시되어 있는 것처럼 블록체인 웹 어플리케이션을 사용하여 확인할 수 있다.

[[transaction-alice]]
[role="smallerseventyfive"]
// .Alice's transaction to Bob's Cafe
.앨리스가 밥의 까페에 지불한 거래
image::images/mbc2_0208.png["Alice Coffee Transaction"]

[[transaction-alice-url]]
[TIP]
====
// View the http://bit.ly/1u0FIGs[transaction from Alice to Bob's Cafe].
http://bit.ly/1u0FIGs[앨리스가 밥의 까페에 지불한 거래] 를 참조하라.
====

// ==== Adding the Transaction to the Ledger
==== 거래 내역을 장부에 추가하기

// The transaction created by Alice's wallet application is 258 bytes long and contains everything necessary to confirm ownership of the funds and assign new owners. Now, the transaction must be transmitted to the bitcoin network where it will become part of the blockchain. In the next section we will see how a transaction becomes part of a new block and how the block is "mined." Finally, we will see how the new block, once added to the blockchain, is increasingly trusted by the network as more blocks are added.
앨리스의 지갑 어플리케이션에서 생성된 거래는 258바이트 크기이며 자금의 소유권을 확인하고 새로운 소유주를 배정하는 데 필요한 모든 정보를 포함하고 있다. 이제 해당 거래는 블록체인의 일부가 되기 위해 비트코인 네트워크로 전송되어야 한다. 다음 섹션에서 어떻게 거래가 새로운 블록의 일부가 되고 블록이 "채굴"되는지 살펴볼 것이다. 마지막으로 새로운 블록이 블록체인에 추가된 후 블록이 계속적으로 추가됨으로써 어떻게 네트워크에 의해 신뢰를 증가시킬 수 있는지 알아볼 것이다.

// ===== Transmitting the transaction
===== 거래 전송하기

// ((("propagation", "process of")))Because the transaction contains all the information necessary to process, it does not matter how or where it is transmitted to the bitcoin network. The bitcoin network is a peer-to-peer network, with each bitcoin client participating by connecting to several other bitcoin clients. The purpose of the bitcoin network is to propagate transactions and blocks to all participants.
((("propagation", "process of")))거래에는 거래를 진행하기 위한 모든 정보가 포함되어 있기 때문에 거래가 비트코인 네트워크로 전송되는 방법이나 장소는 중요하지 않다. 비트코인 네트워크는 P2P 네트워크로 각 비트코인 클라이언트는 여러 다른 비트코인 클라이언트에게 접속함으로써 참여할 수 있다. 비트코인 네트워크의 목적은 거래 내역과 블록을 모든 참여자에게 전파하는 것이다.

// ===== How it propagates
===== 거래 전파하기

// ((("bitcoin nodes", "defined")))((("nodes", see="bitcoin nodes")))Any system, such as a server, desktop application, or wallet, that participates in the bitcoin network by "speaking" the bitcoin protocol is called a _bitcoin node_. Alice's wallet application can send the new transaction to any bitcoin node it is connected to over any type of connection: wired, WiFi, mobile, etc.  Her bitcoin wallet does not have to be connected to Bob's bitcoin wallet directly and she does not have to use the internet connection offered by the cafe, though both those options are possible, too. ((("propagation", "flooding technique")))((("flooding technique")))Any bitcoin node that receives a valid transaction it has not seen before will immediately forward it to all other nodes to which it is connected, a propagation technique known as _flooding_. Thus, the transaction rapidly propagates out across the peer-to-peer network, reaching a large percentage of the nodes within a few seconds.
((("bitcoin nodes", "defined")))((("nodes", see="bitcoin nodes")))비트코인 프로토콜을 "사용하여 (speaking)" 비트코인 네트워크에 참여하는 서버, 데스크탑 어플리케이션, 또는 지갑과 같은 모든 시스템은 _비트코인 노드 (bitcoin node)_ 라고 한다. 유선, 와이파이, 휴대폰 등 어떠한 종류의 인터넷이 연결만 되어 있다면 앨리스의 지갑 어플리케이션에서 모든 비트코인 노드로 새로운 거래를 전송할 수 있다. 앨리스의 비트코인 지갑은 밥의 비트코인 지갑과 직접 연결되어 있을 필요는 없으며, 밥의 까페에서 제공하는 인터넷을 사용하지 않아도 되고 이 두 가지 방법을 모두 사용하는 것도 가능하다. ((("propagation", "flooding technique")))((("flooding technique"))) 이전에는 없던 유효한 거래를 전송받은 비트코인 노드는 연결된 다른 모든 노드에 해당 거래를 즉시 전달하며 이 전파 방식을 _플러딩 (flooding)_ 이라고 한다. 그러므로 거래는 P2P 네트워크를 통해 급속도로 전파되고 몇 초 만에 비트코인 네트워크 내에 있는 대부분의 노드들에게 도달하게 된다.

// ===== Bob's view
===== 밥의 입장에서 살펴보기

// If Bob's bitcoin wallet application is directly connected to Alice's wallet application, Bob's wallet application might be the first node to receive the transaction. However, even if Alice's wallet sends the transaction through other nodes, it will reach Bob's wallet within a few seconds. Bob's wallet will immediately identify Alice's transaction as an incoming payment because it contains outputs redeemable by Bob's keys. Bob's wallet application can also independently verify that the transaction is well formed, uses previously unspent inputs, and contains sufficient transaction fees to be included in the next block. At this point Bob can assume, with little risk, that the transaction will shortly be included in a block and confirmed.
밥의 비트코인 지갑 어플리케이션이 앨리스의 지갑 어플리케이션에 직접 연결되어 있다면, 밥의 지갑 어플리케이션은 해당 거래를 수신하는 첫 번째 노드일 것이다. 그러나 심지어 앨리스의 지갑이 다른 노드를 통해 거래를 전송할 때에도 몇 초 내에 밥의 지갑에 거래가 전송된다. 밥의 지갑은 밥의 키를 이용해서 사용 가능한 출력값을 포함하기 때문에 밥의 지갑은 앨리스의 거래가 전송되면 해당 거래를 통해 돈이 입금된다는 사실을 즉시 파악한다. 또한 밥의 지갑 어플리케이션은 독립적으로 이 거래가 잘 생성되었고 이전에 소비되지 않은 입력값을 사용했으며 다음 블록에 포함될 충분한 거래 수수료를 포함하고 있는지 확인할 수 있다.

[TIP]
====
// ((("confirmations", "of small-value transactions", secondary-sortas="small-value transactions")))A common misconception about bitcoin transactions is that they must be "confirmed" by waiting 10 minutes for a new block, or up to 60 minutes for a full six confirmations. Although confirmations ensure the transaction has been accepted by the whole network, such a delay is unnecessary for small-value items such as a cup of coffee. A merchant may accept a valid small-value transaction with no confirmations, with no more risk than a credit card payment made without an ID or a signature, as merchants routinely accept today.((("", startref="Tconstruct02")))
((("confirmations", "of small-value transactions", secondary-sortas="small-value transactions")))비트코인 거래에 관한 가장 흔한 오해는 새로운 블록을 위해 10분을 기다리거나 6번의 완전한 승인을 위해 최대 60분을 기다려서 "승인"을 받아야 한다는 것이다. 승인은 전체 네트워크가 해당 거래를 승인했다는 것을 보장하지만, 커피 한 잔처럼 소액 결제에 대해서는 시간을 지연시킬 필요가 없다. 상인들은 승인 과정 없이도 유효한 소액 결제를 승인할 수 있으며, 이 경우 현재 상점에서 일상적으로 발생하는 신분증이나 서명 없이 이루어지는 신용카드 결제의 위험도와 유사하다.((("", startref="Tconstruct02")))
====

// === Bitcoin Mining
=== 비트코인 채굴

// ((("mining and consensus", "overview of", id="MACover02")))((("blockchain (the)", "overview of mining", id="BToverview02")))Alice's transaction is now propagated on the bitcoin network. It does not become part of the _blockchain_ until it is verified and included in a block by a process called _mining_. See <<mining>> for a detailed explanation.
((("mining and consensus", "overview of", id="MACover02")))((("blockchain (the)", "overview of mining", id="BToverview02")))앨리스의 거래는 이제 비트코인 네트워크 상에 전파되었다. 이 거래는 _채굴 (mining)_ 이라는 과정에 의해 검증되거나 블록 내 포함되기 전에는 _블록체인 (blockchain)_ 의 일부가 될 수 없다. 자세한 설명은 <<mining>> 을 참조하라.

// The bitcoin system of trust is based on computation. Transactions are bundled into _blocks_, which require an enormous amount of computation to prove, but only a small amount of computation to verify as proven. The mining process serves two purposes in bitcoin:
비트코인 신뢰 시스템은 컴퓨터 연산에 기반한다. 거래들은 _블록 (block)_ 단위로 묶여 있고, 입증하기 위해서는 대규모의 연산력을 필요로 하지만 입증 후에는 검증을 위해서 소량의 연산력만 있어도 된다. 채굴 과정은 비트코인 시스템 내에서 두 가지 목적을 가지고 있다.

// * ((("mining and consensus", "consensus rules", "security provided by")))((("consensus", see="mining and consensus")))Mining nodes validate all transactions by reference to bitcoin's _consensus rules_. Therefore, mining provides security for bitcoin transactions by rejecting invalid or malformed transactions.
* ((("mining and consensus", "consensus rules", "security provided by")))((("consensus", see="mining and consensus")))채굴 노드는 비트코인 _합의 규칙 (consensus rules)_ 을 참조하여 모든 거래를 검증한다. 그러므로 채굴은 유효하지 않거나 잘못된 거래를 거부함으로써 비트코인 거래에 대한 보안을 제공한다.
// * Mining creates new bitcoin in each block, almost like a central bank printing new money. The amount of bitcoin created per block is limited and diminishes with time, following a fixed issuance schedule.
* 채굴은 돈을 새로 발행하는 중앙 은행처럼 각 블록에서 새 비트코인을 생성한다. 블록당 생성되는 비트코인의 양은 제한되며 고정된 발행 스케줄에 따라 시간이 지남에 따라 감소한다.

// Mining achieves a fine balance between cost and reward. Mining uses electricity to solve a mathematical problem. A successful miner will collect a _reward_ in the form of new bitcoin and transaction fees. However, the reward will only be collected if the miner has correctly validated all the transactions, to the satisfaction of the rules of _consensus_. This delicate balance provides security for bitcoin without a central authority.
채굴은 비용과 보상사이의 균형을 잘 맞춘다. 채굴은 수학 문제를 해결하기 위해 전기를 사용한다. 성공한 채굴자는 새로운 비트코인 형태로 _보상 (reward)_ 및 수수료를 받는다. 그러나 채굴자가 _합의 (consensus)_ 규칙을 만족시키면서 모든 거래를 올바르게 검증했을 때에만 보상을 받을 수 있다. 이 섬세한 균형은 중앙 통제없이도 비트코인에 대한 보안을 제공한다.

// A good way to describe mining is like a giant competitive game of sudoku that resets every time someone finds a solution and whose difficulty automatically adjusts so that it takes approximately 10 minutes to find a solution. Imagine a giant sudoku puzzle, several thousand rows and columns in size. If I show you a completed puzzle you can verify it quite quickly. However, if the puzzle has a few squares filled and the rest are empty, it takes a lot of work to solve! The difficulty of the sudoku can be adjusted by changing its size (more or fewer rows and columns), but it can still be verified quite easily even if it is very large. The "puzzle" used in bitcoin is based on a cryptographic hash and exhibits similar characteristics: it is asymmetrically hard to solve but easy to verify, and its difficulty can be adjusted.
대규모 경쟁 게임인 스도쿠와 비교해 봄으로써 채굴 과정을 이해할 수 있다. 이 게임은 누군가가 답을 찾으면 리셋되고 답을 찾기 위해서 대략 10분이 소요되도록 난이도가 자동으로 조절된다. 수천 개의 행과 열로 이루어진 스도쿠 퍼즐이 있다고 상상해 보자. 만약 내가 당신에게 완성된 퍼즐을 보여준다면, 당신은 아주 빨리 퍼즐을 검증할 수 있을 것이다. 그러나 만약 퍼즐이 몇 개만 채워져 있고 나머지 모두가 빈 칸이라면 그것을 풀기 위해서는 많은 노력을 해야할 것이다! 스도쿠 난이도는 그 크기를 변경함으로써 (더 많거나 더 적은 행과 열) 조절할 수 있지만 퍼즐의 크기가 크다고 해서 검증이 어려운 것은 아니다. 비트코인에서 사용되는 "퍼즐"은 암호화된 해시에 기반하며 유사한 특징을 나타낸다: 비대칭으로 해결하기는 어렵지만 검증하기 쉽고 난이도는 조절 가능하다.

// ((("mining and consensus", "mining farms and pools")))In <<user-stories>>, we introduced ((("use cases", "mining for bitcoin")))Jing, an entrepreneur in Shanghai. Jing runs a _mining farm_, which is a business that runs thousands of specialized mining computers, competing for the reward. Every 10 minutes or so, Jing's mining computers compete against thousands of similar systems in a global race to find a solution to a block of transactions. ((("Proof-of-Work algorithm")))((("mining and consensus", "Proof-of-Work algorithm")))Finding such a solution, the so-called _Proof-of-Work_ (PoW), requires quadrillions of hashing operations per second across the entire bitcoin network. The algorithm for Proof-of-Work involves repeatedly hashing the header of the block and a random number with the SHA256 cryptographic algorithm until a solution matching a predetermined pattern emerges. The first miner to find such a solution wins the round of competition and publishes that block into the blockchain.
((("mining and consensus", "mining farms and pools")))<<user-stories>> 에서는, 상하이에 거주하는 ((("use cases", "mining for bitcoin")))사업가인 징을 소개했다. 징은 _채굴장 (mining farm)_ 을 운영하며, 이것은 보상을 얻기 위해 수 천대의 특화된 채굴용 컴퓨터를 가동하는 사업이다. 징의 채굴용 컴퓨터는 매 10분마다 거래가 담겨 있는 블록에 대한 해답을 찾기 위해 전 세계적으로 수 천명의 다른 채굴자들과 함께 경쟁한다. ((("Proof-of-Work algorithm")))((("mining and consensus", "Proof-of-Work algorithm")))이러한 해답을 찾는 작업을 _작업 증명 (Proof-of-Work, PoW)_ 이라고 하며, 전체 비트코인 네트워크에 걸쳐 1초당 수 천 조건 이상의 해싱 작업을 필요로 한다. 작업 증명 알고리즘은 설정된 유형에 일치하는 해답이 나올 때 까지 SHA256 암호화 알고리즘을 이용하여 블록의 헤더와 임의의 숫자를 반복적으로 해싱한다. 이 해답을 찾은 첫 번째 채굴자가 이 경쟁의 승자가 되고 채굴한 블록은 블록체인으로 올라간다.

// Jing started mining in 2010 using a very fast desktop computer to find a suitable Proof-of-Work for new blocks. As more miners started joining the bitcoin network, the difficulty of the problem increased rapidly. Soon, Jing and other miners upgraded to more specialized hardware, such as high-end dedicated graphical processing units (GPUs) cards such as those used in gaming desktops or consoles. At the time of this writing, the difficulty is so high that it is profitable only to mine with ((("application-specific integrated circuits (ASIC)")))application-specific integrated circuits (ASIC), essentially hundreds of mining algorithms printed in hardware, running in parallel on a single silicon chip. ((("mining pools", "defined")))Jing's company also participates in a _mining pool_, which much like a lottery pool allows several participants to share their efforts and rewards. Jing's company now runs a warehouse containing thousands of  ASIC miners to mine for bitcoin 24 hours a day. The company pays its electricity costs by selling the bitcoin it is able to generate from mining, creating some income from the profits.
징은 새로운 블록에 대해 적절한 작업 증명을 수행하기 위해 매우 빠른 데스크탑 컴퓨터를 사용하여 2010년부터 채굴을 시작했다. 더 많은 채굴자들이 비트코인 네트워크에 참여하기 시작하면서, 문제 난이도는 빠르게 증가했다. 그러자 징과 다른 채굴자들은 게임용 데스크탑이나 콘솔 등 고가의 전용 그래픽 처리장치 (GPU) 카드 등 좀 더 특화된 하드웨어로 업그레이드 했다. 이 책을 쓸 당시에도 난이도가 너무 높아져서 하나의 실리콘 칩위에 동시에 가동되는, 하드웨어상에 수백 개의 채굴 알고리즘이 새겨져 있는 ((("application-specific integrated circuits (ASIC)")))주문형 반도체 (ASIC)를 사용할 경우에만 수익성이 있었다. ((("mining pools", "defined")))징의 회사 또한 _채굴풀 (mining pool)_ 에 참여했으며, 이는 복권풀 (lottery pool)과 유사하며 여러 참가자들이 기여와 보상을 공유한다. 현재 징의 회사는 하루 24시간내내 비트코인을 채굴하기 위해 수 천대의 ASIC 채굴기를 보유한 공장을 운영하고 있다. 회사는 채굴로 얻은 비트코인을 매도하여 전기세를 지불하고, 비트코인 채굴을 통해 얻은 이익으로 수입을 만든다.

// === Mining Transactions in Blocks
=== 블록에 담겨 있는 거래 채굴하기

// ((("blocks", "mining transactions in")))New transactions are constantly flowing into the network from user wallets and other applications. As these are seen by the bitcoin network nodes, they get added to a temporary pool of unverified transactions maintained by each node. As miners construct a new block, they add unverified transactions from this pool to the new block and then attempt to prove the validity of that new block, with the mining algorithm (Proof-of-Work). The process of mining is explained in detail in <<mining>>.
((("blocks", "mining transactions in")))사용자 지갑이나 다른 어플리케이션을 통해 새로운 거래들이 네트워크로 지속적으로 들어온다. 비트코인 네트워크 노드들은 이것을 지켜보다가 각 노드가 유지하고 있는 임시 풀 (temporary pool)로 이 미검증 거래들을 추가한다. 채굴자가 새로운 블록을 생성하면, 이 새로운 블록에 임시 풀에 있는 미검증 거래를 추가한 후 마이닝 알고리즘 (작업 증명)을 이용하여 새 블록의 유효성을 입증하려고 한다. 채굴 과정은 <<mining>>에서 더 자세하게 설명된다.

// Transactions are added to the new block, prioritized by the highest-fee transactions first and a few other criteria. Each miner starts the process of mining a new block of transactions as soon as he receives the previous block from the network, knowing he has lost that previous round of competition. He immediately creates a new block, fills it with transactions and the fingerprint of the previous block, and starts calculating the Proof-of-Work for the new block. Each miner includes a special transaction in his block, one that pays his own bitcoin address the block reward (currently 12.5 newly created bitcoin) plus the sum of transaction fees from all the transactions included in the block. If he finds a solution that makes that block valid, he "wins" this reward because his successful block is added to the global blockchain and the reward transaction he included becomes spendable. ((("mining pools", "operation of")))Jing, who participates in a mining pool, has set up his software to create new blocks that assign the reward to a pool address. From there, a share of the reward is distributed to Jing and other miners in proportion to the amount of work they contributed in the last round.
거래는 새로운 블록에 추가될 때 거래 수수료가 가장 높은 거래부터 우선순위로 추가되고 몇몇 거래는 다른 기준을 바탕으로 추가된다. 각 채굴자는 네트워크로부터 이전 블록을 받게 되면 이전 경쟁 라운드에서 채굴에 실패했다는 사실을 알게되고 새로운 블록 채굴 과정을 시작한다. 그는 즉시 새로운 블록을 생성하고 거래 내역과 이전 블록의 지문을 채운 후 새로운 블록에 대한 작업 증명 계산을 시작한다. 각 채굴자는 자신의 블록 안에 특별한 거래 내역을 포함하고 있는데, 이는 자신 소유의 비트코인 주소에 블록 보상 (현재는 한 블록당 12.5 비트코인)과 블록에 포함된 모든 거래 수수료의 합을 받는 거래이다. 만약 채굴자가 블록을 유효하게 만드는 해답을 찾게 되면, 글로벌 블록체인에 해답을 찾은 블록이 추가되므로 채굴자는 보상을 "받게되며(win)" 블록에 포함된 보상 거래를 소비할 수 있게 된다. ((("mining pools", "operation of"))) 채굴풀에서 활동중인 징은 새 블록을 생성하게 되면 보상을 풀의 주소로 받게하는 소프트웨어를 설정했다. 이렇게 되면, 지난 채굴 작업에서 시행했던 작업량에 따라 징과 다른 채굴자들에게 보상금이 분배된다.

// ((("candidate blocks")))((("blocks", "candidate blocks")))Alice's transaction was picked up by the network and included in the pool of unverified transactions. Once validated by the mining software it was included in a new block, called a _candidate block_, generated by Jing's mining pool. All the miners participating in that mining pool immediately start computing Proof-of-Work for the candidate block. Approximately five minutes after the transaction was first transmitted by Alice's wallet, one of Jing's ASIC miners found a solution for the candidate block and announced it to the network. Once other miners validated the winning block they started the race to generate the next block.
((("candidate blocks")))((("blocks", "candidate blocks")))앨리스의 거래가 네트워크에서 선택되어 미검증 거래들로 이루어진 풀에 포함되었다. 채굴 소프트웨어에 의해 검증되면 징의 채굴풀이 생성한 새로운 블록에 추가되고 이 블록을 _예비 블록 (candidate block)_ 이라고 한다. 채굴풀에 참여한 모든 채굴자들은 즉시 예비 블록에 대한 작업 증명 연산을 시작한다. 앨리스의 거래가 지갑에서 처음 전송된 후 약 5분이 경과하고 나서 징의 ASIC 채굴기 중 하나가 예비 블록에 대한 답을 찾았고 네트워크상에 이를 게시했다. 다른 채굴자가 이 블록을 검증하고나면 그들은 다음 블록 생성을 위한 경쟁을 시작한다.

// Jing's winning block became part of the blockchain as block #277316, containing 419 transactions, including Alice's transaction. The block containing Alice's transaction is counted as one "confirmation" of that transaction.
징의 블록은 419개의 거래가 담겨 있는 블록 #277316으로써 블록체인의 일부가 되었고 앨리스의 거래를 포함한다. 앨리스의 거래를 포함한 블록은 그 거래에 대한 하나의 "승인"으로 셀 수 있다.

[TIP]
====
// You can see the block that includes https://blockchain.info/block-height/277316[Alice's transaction].
https://blockchain.info/block-height/277316[앨리스의 거래] 를 포함한 블록을 확인할 수 있다.
====

// ((("confirmations", "role in transactions")))Approximately 19 minutes later, a new block, #277317, is mined by another miner. Because this new block is built on top of block #277316 that contained Alice's transaction, it added even more computation to the blockchain, thereby strengthening the trust in those transactions. Each block mined on top of the one containing the transaction counts as an additional confirmation for Alice's transaction. As the blocks pile on top of each other, it becomes exponentially harder to reverse the transaction, thereby making it more and more trusted by the network.
((("confirmations", "role in transactions")))대략 19분 후에 다른 채굴자가 새로운 블록 #277317을 채굴하였다. 이 새로운 블록은 앨리스의 거래를 포함한 이전 블록 #277316을 기반으로 하기 때문에 블록체인에 더 많은 연산이 추가되고 이 거래에 대한 신뢰를 강화할 수 있다. 앨리스의 거래가 포함된 블록의 상부에 채굴된 새로운 블록이 추가되면 추가적인 승인을 받게 된다. 각 블록이 서로의 상부에 쌓이기 때문에 거래 철회는 기하급수적으로 어려워지며 해당 거래는 네트워크상에서 더욱더 신뢰할 수 있게 된다.

// ((("genesis block")))((("blocks", "genesis block")))((("blockchain (the)", "genesis block")))In the diagram in <<block-alice1>>,  we can see block #277316, which contains Alice's transaction. Below it are 277,316 blocks (including block #0), linked to each other in a chain of blocks (blockchain) all the way back to block #0, known as the _genesis block_. Over time, as the "height" in blocks increases, so does the computation difficulty for each block and the chain as a whole. The blocks mined after the one that contains Alice's transaction act as further assurance, as they pile on more computation in a longer and longer chain. By convention, any block with more than six confirmations is considered irrevocable, because it would require an immense amount of computation to invalidate and recalculate six blocks. We will examine the process of mining and the way it builds trust in more detail in <<mining>>.((("", startref="BToverview02")))((("", startref="MACover02")))
((("genesis block")))((("blocks", "genesis block")))((("blockchain (the)", "genesis block")))<<block-alice1>> 의 그림에서, 앨리스의 거래를 포함한 블록 #277316을 볼 수 있다. 그 아래는 277,316 블록 (블록 #0을 포함해서)이 존재하며 _최초 블록 (genesis block)_ 으로 알려진 블록 #0까지 이어져 있는 블록 사슬 (블록체인)에서 서로 연결되어 있다. 시간이 지날수록 블록의 "높이"가 커지고 각 블록과 체인의 계산 난이도도 증가한다. 앨리스의 거래를 포함한 블록 후에 채굴되는 블록들은 체인의 길이가 길어질수록 연산이 증가하기 때문에 더 강력하게 앨리스의 거래를 보증한다. 일반적으로 6회 이상의 승인이 이루어진 블록은 취소가 불가능하다. 이는 여섯 개의 블록을 무효화해서 다시 계산하기 위해서는 엄청난 양의 연산력이 필요하기 때문이다. 채굴 과정과 신뢰를 형성하는 방법에 대해 <<mining>> 에서 더 자세하게 살펴볼 것이다.((("", startref="BToverview02")))((("", startref="MACover02")))

[[block-alice1]]
// .Alice's transaction included in block #277316
.블록 #277316에 포함된 앨리스의 거래
image::images/mbc2_0209.png["Alice's transaction included in a block"]

// === Spending the Transaction
=== 거래 소비하기

// ((("spending bitcoin", "simple-payment-verification (SPV)")))((("simple-payment-verification (SPV)")))Now that Alice's transaction has been embedded in the blockchain as part of a block, it is part of the distributed ledger of bitcoin and visible to all bitcoin applications. Each bitcoin client can independently verify the transaction as valid and spendable. Full-node clients can track the source of the funds from the moment the bitcoin were first generated in a block, incrementally from transaction to transaction, until they reach Bob's address. Lightweight clients can do what is called a simplified payment verification (see <<spv_nodes>>) by confirming that the transaction is in the blockchain and has several blocks mined after it, thus providing assurance that the miners accepted it as valid.
((("spending bitcoin", "simple-payment-verification (SPV)")))((("simple-payment-verification (SPV)")))앨리스의 거래는 블록의 일부로 블록체인에 포함되어 있으므로, 비트코인 분산 원장의 한 부분이 되고 모든 비트코인 어플리케이션에서 확인 가능하다. 각 비트코인 클라이언트는 거래가 유효하고 지불 가능한 지 독립적으로 검증 할 수 있다. 풀 노드 클라이언트는 비트코인이 블록에서 처음 생성된 순간부터 이 거래에서 저 거래로 이동해서 최종적으로 밥의 비트코인 주소에 도달할 때까지 자금 출처를 추적할 수 있다. 라이트웨이트 클라이언트는 해당 거래가 블록체인 내에 존재하고 그 후 채굴된 블록이 여러 개 있다는 점을 승인함으로써 단순 지불 검증 (simplified payment verification, <<spv_nodes>> 를 참고하라)을 실행할 수 있다. 이를 통해 채굴자가 해당 거래를 유효하다고 수락했음을 확증 할 수 있다.

// Bob can now spend the output from this and other transactions. For example, Bob can pay a contractor or supplier by transferring value from Alice's coffee cup payment to these new owners. Most likely, Bob's bitcoin software will aggregate many small payments into a larger payment, perhaps concentrating all the day's bitcoin revenue into a single transaction. This would aggregate the various payments into a single output (and a single address). For a diagram of an aggregating transaction, see <<transaction-aggregating>>.
밥은 이 거래와 다른 거래로부터의 출력값을 소비할 수 있다. 예를 들어, 밥은 앨리스가 커피 한 잔에 대해 지불한 금액을 새로운 소유주에게 전송함으로써 계약자나 공금업자에게 대금을 지불할 수 있다. 아마 밥의 비트코인 소프트웨어는 하루동안 벌어들이는 비트코인 수익을 하나의 거래로 모으기 위해 많은 소액 지불을 더 큰 금액의 지불 금액으로 합칠 것이다. 이러한 과정은 다양한 지불 거래 내역을 하나의 출력값 (하나의 주소)로 합하게 된다. 거래를 합치는 과정에 대한 도식은 <<transaction-aggregating>> 를 참고하라.

// As Bob spends the payments received from Alice and other customers, he extends the chain of transactions. Let's assume that Bob pays his web designer Gopesh((("use cases", "offshore contract services"))) in Bangalore for a new website page. Now the chain of transactions will look like <<block-alice2>>.
밥이 앨리스나 다른 고객들로부터 받은 지불금을 소비하면서 거래 내역 체인을 연장하게 된다. 밥이 새로운 웹사이트 페이지를 위해 방갈로에 사는 웹 디자이너 조셉((("use cases", "offshore contract services")))에게 지불해야 하는 상황을 가정해 보자. 이제 거래 체인은 <<block-alice2>> 와 같은 모양일 것이다.

[[block-alice2]]
// .Alice's transaction as part of a transaction chain from Joe to Gopesh
.조에서 조셉에 이르기까지의 거래 체인의 일부를 구성하는 앨리스의 거래
image::images/mbc2_0210.png["Alice's transaction as part of a transaction chain"]

// In this chapter, we saw how transactions build a chain that moves value from owner to owner. We also tracked Alice's transaction, from the moment it was created in her wallet, through the bitcoin network and to the miners who recorded it on the blockchain. In the rest of this book, we will examine the specific technologies behind wallets, addresses, signatures, transactions, the network, and finally mining.((("", startref="BCover02")))((("", startref="DCSover02"))) ((("", startref="UCcoffee02")))
이 장에서는 거래가 어떻게 소유주 사이의 가치 이동을 나타내는 체인을 구성하는지에 대해 살펴보았다. 또한 앨리스의 지갑에서 거래가 생성된 순간부터 비트코인 네트워크를 통해 이 거래를 블록체인에 기록하는 채굴자에 이르기까지 앨리스의 거래를 추적하였다. 이 책의 나머지 부분에서는 지갑, 주소, 서명, 거래, 네트워크 및 마지막으로 채굴까지 구체적인 기술에 대해 알아 볼 것이다.((("", startref="BCover02")))((("", startref="DCSover02"))) ((("", startref="UCcoffee02")))
